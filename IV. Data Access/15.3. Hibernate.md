15.3 Hibernate
========================

现在要开始谈下 Spring 环境中的 [Hibernate 3](http://www.hibernate.org/)，用它来展示 Spring 对集成 O/R 映射的方法。本节将详细讨论许多问题,并显示不同的 DAO 实现和事务界定。大多数这些模式可以直接从所有其他支持 ORM 的工具中转换。以下部分在本章将覆盖其他的 ORM 技术,并显示简短的例子。

*对于Spring 4.0, Spring 需要 Hibernate 3.6 或者更高版本*

###15.3.1 SessionFactory setup in a Spring container 在 Spring 容器中设置 SessionFactory

为了避免应用程序对象与硬编码的资源查找想绑定，您可以定义资源如 JDBC `DataSource` 或者 Hibernate `SessionFactory` 为 Spring 容器的 bean。应用对象需要通过对 bean 的引用来访问资源接受引用，就如在下一节中说明的 DAO 的定义。

以下摘录自 XML 应用程序上下文定义，展示了如何设置 JDBC `DataSource` 或者 Hibernate `SessionFactory` :

	<beans>
	
	    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
	        <property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
	        <property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
	        <property name="username" value="sa"/>
	        <property name="password" value=""/>
	    </bean>
	
	    <bean id="mySessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
	        <property name="dataSource" ref="myDataSource"/>
	        <property name="mappingResources">
	            <list>
	                <value>product.hbm.xml</value>
	            </list>
	        </property>
	        <property name="hibernateProperties">
	            <value>
	                hibernate.dialect=org.hibernate.dialect.HSQLDialect
	            </value>
	        </property>
	    </bean>
	
	</beans>

从 Jakarta Commons DBCP `BasicDataSource` 转为 JNDI-located `DataSource`, 主要的配置为：

	<beans>
	    <jee:jndi-lookup id="myDataSource" jndi-name="java:comp/env/jdbc/myds"/>
	</beans>

您还可以访问 JNDI-located `SessionFactory`,使用 Spring 的`JndiObjectFactoryBean`/`<jee:jndi-lookup>` 来检索和暴露他。然而,通常在 EJB 环境外不常用。

###15.3.2 Implementing DAOs based on plain Hibernate 3 API
基于平常的 Hibernate 3 API 来实现 DAO

Hibernate 3 有一个特性称为上下文会话,Hibernate 本身在每个事务管理一个当前 `Session` 。这是大致相当于 Spring 的 每个事务一个当前 Hibernate `Session`的同步。相应的 DAO 实现像下面的例子,基于普通Hibernate API:

	public class ProductDaoImpl implements ProductDao {
	
	    private SessionFactory sessionFactory;
	
	    public void setSessionFactory(SessionFactory sessionFactory) {
	        this.sessionFactory = sessionFactory;
	    }
	
	    public Collection loadProductsByCategory(String category) {
	        return this.sessionFactory.getCurrentSession()
	                .createQuery("from test.Product product where product.category=?")
	                .setParameter(0, category)
	                .list();
	    }
	}

这种风格类似于 Hibernate 参考文档和例子,除了在一个实例变量中保存 `SessionFactory`。我们强烈建议基于实例的设置,替换老派的Hibernate 的 CaveatEmptor 示例应用程序中的`static` `HibernateUtil`类。(一般来说,不保留任何资源`static`变量,除非绝对必要)

上面的 DAO 是依赖注入模式:这正好符合 Spring IoC 容器,就像对Spring 的 `HibernateTemplate` 编码。当然,这种 DAO 也可以在普通的 Java 设置(例如,在单元测试)。简单的实例化,并用所需的工厂引用调用`setSessionFactory(..)`。Spring bean 定义 DAO 就像下面一样:
	
	<beans>
	
	    <bean id="myProductDao" class="product.ProductDaoImpl">
	        <property name="sessionFactory" ref="mySessionFactory"/>
	    </bean>
	
	</beans>

DAO 风格的主要优点是，它只依赖于 Hibernate API ，而没有引进任何Spring 必需的类。从非侵入性的视角看这当然是有吸引力的，对Hibernate 开发者来说无疑会感觉更自然。

然而，DAO 将平常的 `HibernateException`（这是未检查的，所以不需要声明或者捕获），这意味着调用者当异常为一个普通的致命问题——除非他们想要依赖于 Hibernate 自身的异常结构。捕捉乐观锁定失败等具体原因是不可能除非把调用者与实现策略相联系。取消这交换是可接受的对于应用程序是基于 Hibernate 和/或 不需要任何特殊的异常处理。

幸运的是,Spring 的 `LocalSessionFactoryBean` 支持 Hibernate `SessionFactory.getCurrentSession()`方法用于任何 Spring 事务策略,返回当前 Spring 管理的事务 `Session`即使是`HibernateTransactionManager.`。当然,这种方法的标准行为返回仍然是当前`Session`与持续的JTA事务有关。这种行为适用于不管您使用是Spring 的 `JtaTransactionManager`,EJB容器管理的事务(CMT),或 JTA。

总之:你可以基于平常的 Hibernate 3 API 来实现 DAO,同时仍然能够参与 Spring 管理事务。

###15.3.3 Declarative transaction demarcation 声明式事务划分

建议你使用 Spring 声明式事务的支持,这使您能够代替显式事务划分 API调用 AOP 事务拦截器中的 Java 代码。这个事务拦截器可以配置 Spring容器通过使用 Java 注释或 XML。这个声明式事务能力允许您保持业务服务中的重复性事务划分代码码更自由，并且让你只关注添加业务逻辑,而这是您的应用程序的真正价值。

*在继续之前，强烈建议你读[12.5节，“事务管理”](12.5. Declarative transaction management.md)如果你还没有这样做。*

此外，事务语义比如传播行为和隔离水平可以在配置文件的改变，不影响业务服务的实现。

下面的示例说明如何使用 XML 配置 AOP 事务拦截器，一个简单的服务类：

	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
	    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	    xmlns:aop="http://www.springframework.org/schema/aop"
	    xmlns:tx="http://www.springframework.org/schema/tx"
	    xsi:schemaLocation="
	        http://www.springframework.org/schema/beans
	        http://www.springframework.org/schema/beans/spring-beans.xsd
	        http://www.springframework.org/schema/tx
	        http://www.springframework.org/schema/tx/spring-tx.xsd
	        http://www.springframework.org/schema/aop
	        http://www.springframework.org/schema/aop/spring-aop.xsd">
	
	    <!-- SessionFactory, DataSource, etc. omitted -->
	
	    <bean id="transactionManager"
	            class="org.springframework.orm.hibernate3.HibernateTransactionManager">
	        <property name="sessionFactory" ref="sessionFactory"/>
	    </bean>
	
	    <aop:config>
	        <aop:pointcut id="productServiceMethods"
	                expression="execution(* product.ProductService.*(..))"/>
	        <aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/>
	    </aop:config>
	
	    <tx:advice id="txAdvice" transaction-manager="myTxManager">
	        <tx:attributes>
	            <tx:method name="increasePrice*" propagation="REQUIRED"/>
	            <tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/>
	            <tx:method name="*" propagation="SUPPORTS" read-only="true"/>
	        </tx:attributes>
	    </tx:advice>
	
	    <bean id="myProductService" class="product.SimpleProductService">
	        <property name="productDao" ref="myProductDao"/>
	    </bean>
	
	</beans>

下面是要处理的服务类
	
	public class ProductServiceImpl implements ProductService {
	
	    private ProductDao productDao;
	
	    public void setProductDao(ProductDao productDao) {
	        this.productDao = productDao;
	    }
	
	    // notice the absence of transaction demarcation code in this method
	    // Spring's declarative transaction infrastructure will be demarcating
	    // transactions on your behalf
	    public void increasePriceOfAllProductsInCategory(final String category) {
	        List productsToChange = this.productDao.loadProductsByCategory(category);
	        // ...
	    }
	}

我们还展示了一个基于配置属性的支持，在下面的例子中。你通过 `@Transactional`注释的服务层,并引导 Spring 容器找到这些注释，这些注释的方法提供事务性语义。

	public class ProductServiceImpl implements ProductService {
	
	    private ProductDao productDao;
	
	    public void setProductDao(ProductDao productDao) {
	        this.productDao = productDao;
	    }
	
	    @Transactional
	    public void increasePriceOfAllProductsInCategory(final String category) {
	        List productsToChange = this.productDao.loadProductsByCategory(category);
	        // ...
	    }
	
	    @Transactional(readOnly = true)
	    public List<Product> findAllProducts() {
	        return this.productDao.findAllProducts();
	    }
	
	}

正如你可以看到下面的配置实例，配置更加简化，与上述 XML 实例，同时还提供了在服务层的代码注释驱动相同的功能。所有您需要提供的是TransactionManager 的实现和“<tx:annotation-driven/>" 实体

	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
	    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	    xmlns:aop="http://www.springframework.org/schema/aop"
	    xmlns:tx="http://www.springframework.org/schema/tx"
	    xsi:schemaLocation="
	        http://www.springframework.org/schema/beans
	        http://www.springframework.org/schema/beans/spring-beans.xsd
	        http://www.springframework.org/schema/tx
	        http://www.springframework.org/schema/tx/spring-tx.xsd
	        http://www.springframework.org/schema/aop
	        http://www.springframework.org/schema/aop/spring-aop.xsd">
	
	    <!-- SessionFactory, DataSource, etc. omitted -->
	
	    <bean id="transactionManager"
	            class="org.springframework.orm.hibernate3.HibernateTransactionManager">
	        <property name="sessionFactory" ref="sessionFactory"/>
	    </bean>
	
	    <tx:annotation-driven/>
	
	    <bean id="myProductService" class="product.SimpleProductService">
	        <property name="productDao" ref="myProductDao"/>
	    </bean>
	
	</beans>

###15.3.4 Programmatic transaction demarcation 编程式事务划分



