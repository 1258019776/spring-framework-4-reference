9.2 @AspectJ support 关于 @AspectJ 的支持
========================

@AspectJ 可以将切面声明为普通的 Java 类。 AspectJ 5发布的 [AspectJ project](http://www.eclipse.org/aspectj) 中引入了这种 @AspectJ 风格。Spring 使用了和 AspectJ 5 一样的注解，使用了 AspectJ 提供的一个库来做 pointcut（切点）解析和匹配。 但是，AOP 在运行时仍旧是纯的 Spring AOP，并不依赖于 AspectJ 的编译器或者 weaver（织入器）。

使用 AspectJ 的编译器或者 weaver（织入器）的话就可以使用完整的AspectJ 语言，我们将在[9.8. Using AspectJ with Spring applications](9.8. Using AspectJ with Spring applications.md)中讨论这个问题 

###9.2.1 Enabling @AspectJ Support 启用支持

为了在 Spring 配置中使用 @AspectJ aspects，你必须首先启用Spring 对基于 @AspectJ aspects 的配置支持，autoproxying（自动代理）基于通知是否来自这些切面。 自动代理是指 Spring 会判断一个bean 是否使用了一个或多个切面通知，并据此自动生成相应的代理以拦截其方法调用，并且确认通知是否如期进行。

通过 XML 或者 Java 配置来 启用 @AspectJ 支持。在任何情况下，你还需要确保 AspectJ `aspectjweaver.jar`在你的应用程序的类路径中（版本 1.6.8 或以后）。这个库在 AspectJ 发布的 `lib` 目录中或通过Maven 的 中央存库得到。

####用 Java 配置

使用 @Configuration 和 @EnableAspectJAutoProxy 注解:

	@Configuration
	@EnableAspectJAutoProxy
	public class AppConfig {
	
	}

####使用 XML 配置

使用 aop:aspectj-autoproxy 元素:

	<aop:aspectj-autoproxy/>


###9.2.2 Declaring an aspect 声明一个切面

在启用 @AspectJ 支持的情况下，在application context中定义的任意带有一个 @Aspect 切面（拥有 @Aspect 注解）的 bean 都将被Spring自动识别并用于配置在 Spring AOP。 以下例子展示了为了完成一个不是非常有用的切面所需要的最小定义：

下面是在application context 中的一个常见的 bean 定义，这个 bean 指向一个使用了 @Aspect 注解的 bean 类：

	<bean id="myAspect" class="org.xyz.NotVeryUsefulAspect">
	    <!-- configure properties of aspect here as normal -->
	</bean>

下面是 NotVeryUsefulAspect 类定义，使用了 org.aspectj.lang.annotation.Aspect 注解。

	package org.xyz;
	import org.aspectj.lang.annotation.Aspect;
	
	@Aspect
	public class NotVeryUsefulAspect {
	
	}

切面（用 @Aspect 注解的类）和其他类一样有方法和字段定义。他们也可能包括切入点，通知和引入（inter-type）声明。

*你可以注册 切面 像其他 bean 一样在 Spring 的 XML 进行配置，或自动通过类路径扫描-就像任何其他的 Spring 管理的 bean。然而，请注意，@Aspect 的注解是不足以在 classpath 自动检测到了：为了这个目的，你需要添加一个单独的 @Component 的注解（或者自定义stereotype annotation 即 qualifies，作为 Spring 组件的扫描规则）。*

*在 Spring AOP 中，它是不可能使自己的切面成为 其他切面的通知的目标的。类上的 @Aspect 注解标记 它成为一个切面，因此从 auto-proxying 中排除了它。*

###9.2.3 Declaring a pointcut 声明一个切入点

回想一下，切入点决定了连接点关注的内容，使得我们可以控制通知什么执行。 Spring AOP 只支持 Spring bean 方法执行连接点。所以你可以把切入点看做是匹配 Spring bean 上的方法执行。 一个切入点声明有两个部分：一个包含名字和任意参数的签名，还有一个切入点表达式，该表达式决定了我们关注那个方法的执行。 在 @AspectJ 中，一个切入点实际就是一个普通的方法定义提供的一个签名，并且切入点表达式使用 @Pointcut 注解来表示（这个方法的返回类型必须是 void）。 

如下的例子定义了一个切入点'anyOldTransfer'，这个切入点匹配了任意名为`transfer`的方法执行

	@Pointcut("execution(* transfer(..))")// the pointcut expression
	private void anyOldTransfer() {}// the pointcut signature

切入点表达式，也就是 @Pointcut 注解的值，是正规的 AspectJ 5 切入点表达式。 如果你想要更多了解 AspectJ 的 切入点语言，请参见[AspectJ 编程指南](http://www.eclipse.org/aspectj/doc/released/progguide/index.html)（如果要了解扩展请[参阅 AspectJ 5 开发手册](http://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html)） 或者其他人写的关于 AspectJ 的书，例如 Colyer et. al.著的《Eclipse AspectJ》或者 Ramnivas Laddad著的《AspectJ in Action》。

####支持的切入点指定者

Spring AOP 支持在切入点表达式中使用如下的  AspectJ pointcut designators (切入点指定者 PCD) ：

*其他的切入点类型*

*完整的 AspectJ 切入点语言支持额外的切入点指定者，但是 Spring 不支持这个功能。 他们分别是call, get, set, preinitialization, staticinitialization, initialization, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this, 和 @withincode 。 在 Spring AOP 中使用这些指定者将会导致抛出IllegalArgumentException 异常。*

*在 Spring AOP 设置切入点指定者可能会在未来的发布中进行扩展，用来支持更多 AspectJ 切入点指定者。*

* execution - 匹配方法执行的连接点，这是你将会用到的 Spring 的最主要的切入点指定者。
* within - 限定匹配特定类型的连接点（在使用 Spring AOP 的时候，在匹配的类型中定义的方法的执行）。
* this - 限定匹配特定的连接点（使用 Spring AOP 的时候方法的执行），其中 bean reference（Spring AOP 代理）是指定类型的实例。
* target - 限定匹配特定的连接点（使用 Spring AOP 的时候方法的执行），其中目标对象（被代理的 appolication object ）是指定类型的实例。
* args - 限定匹配特定的连接点（使用 Spring AOP 的时候方法的执行），其中参数是指定类型的实例。
* @target - 限定匹配特定的连接点（使用 Spring AOP 的时候方法的执行），其中执行的对象的类已经有指定类型的注解。
* @args - 限定匹配特定的连接点（使用 Spring AOP 的时候方法的执行），其中实际传入参数的运行时类型有指定类型的注解。
* @within - 限定匹配特定的连接点，其中连接点所在类型已指定注解（在使用 Spring AOP 的时候，所执行的方法所在类型已指定注解）。
* @annotation - 限定匹配特定的连接点（使用 Spring AOP 的时候方法的执行），其中连接点的主题有某种给定的注解。

因为 Spring AOP 限制了连接点必须是方法执行级别的，pointcut designators 的讨论也给出了一个定义，这个定义和 AspectJ 的编程指南中的定义相比显得更加狭窄。 除此之外，AspectJ 它本身有基于类型的语义，在执行的连接点'this'和'target'都是指同一个对象，也就是执行方法的对象。 Spring AOP 是一个基于代理的系统，并且严格区分代理对象本身（对应于'this'）和背后的目标对象（对应于'target'）

Due to the proxy-based nature of Spring’s AOP framework, protected methods are by definition not intercepted, neither for JDK proxies (where this isn’t applicable) nor for CGLIB proxies (where this is technically possible but not recommendable for AOP purposes). As a consequence, any given pointcut will be matched against public methods only!
If your interception needs include protected/private methods or even constructors, consider the use of Spring-driven native AspectJ weaving instead of Spring’s proxy-based AOP framework. This constitutes a different mode of AOP usage with different characteristics, so be sure to make yourself familiar with weaving first before making a decision.